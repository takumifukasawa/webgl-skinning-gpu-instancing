<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>cpu-skinning</title>
    <style>
        #js-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #js-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

<div id="js-wrapper">
    <canvas id="js-canvas"></canvas>
</div>

<script type="module">

import { AttributeUsageTypes, UniformTypes } from "./js/constants.js";
import { Matrix4 } from "./js/Matrix4.js";
import { Vector3 } from "./js/Vector3.js";
import { GPU } from "./js/GPU.js";
import { VertexArrayObject } from "./js/VertexArrayObject.js";
import { Shader } from "./js/Shader.js";
import { Bone } from "./js/Bone.js";

// ----------------------------------------------------------------------------------
// variables
// ----------------------------------------------------------------------------------

const wrapperElement = document.getElementById("js-wrapper")
const canvasElement = document.getElementById("js-canvas");
const gl = canvasElement.getContext("webgl2", { antialias: false });

// const pixelRatio = Math.min(window.devicePixelRatio, 1.5);

const gpu = new GPU({ gl });

// ----------------------------------------------------------------------------------
// functions
// ----------------------------------------------------------------------------------

const createGeometry = () => {
    // -----------------------------
    // # position indices
    // -----------------------------
    //   22 --- 23
    //  /|     /|
    // 20 --- 21|
    // | 18 --| 19
    // |/     |/|
    // 16 --- 17|
    // | 14 --| 15
    // |/|    |/|
    // 12 --- 13|
    // | 10 --| 11
    // |/|    |/|
    // 8 ---- 9 |
    // | 6 ---| 7
    // |/|    |/|
    // 4 ---- 5 |
    // | 2 -- | 3
    // |/     |/
    // 0 ---- 1
    // -----------------------------

    // -----------------------------
    // # bone indices (front view)
    // boneは5個
    // -----------------------------
    // 20 --- 21 ... 5段目
    // |      |
    // |  b4  |
    // |      |
    // 16 --- 17 ... 4段目
    // |      |
    // |  b3  |
    // |      |
    // 12 --- 13 ... 3段目
    // |      |
    // |  b2  |
    // |      |
    // 8 ---- 9  ... 2段目
    // |      |
    // |  b1  |
    // |      |
    // 4 ---- 5  ... 1段目
    // |      |
    // |  b0  |
    // |      |
    // 0 ---- 1  ... 0段目
    // -----------------------------
  
    // 影響するboneのindex  
    // 4つまで指定可能
    const boneIndicesEachHeight = [
        [0, 0, 0, 0], // 0段目: b0
        [0, 1, 0, 0], // 1段目: b1
        [1, 2, 0, 0], // 2段目: b1,b2
        [2, 3, 0, 0], // 3段目: b2,b3
        [3, 4, 0, 0], // 4段目: b3,b4
        [4, 0, 0, 0], // 5段目: b4
    ];
   
    // 影響するboneのindexごとの重さ
    const boneWeightsEachHeight = [
        [1, 0, 0, 0],       // 0段目: b0 * 1
        [0.5, 0.5, 0, 0],   // 1段目: b0 * 0.5, b1 * 0.5
        [0.5, 0.5, 0, 0],   // 2段目: b1 * 0.5, b2 * 0.5
        [0.5, 0.5, 0, 0],   // 3段目: b2 * 0.5, b3 * 0.5
        [0.5, 0.5, 0, 0],   // 4段目: b3 * 0.5, b4 * 0.5
        [1, 0, 0, 0],       // 5段目: b4 * 1
    ];
   
    const boxFaces = [
        [0, 2, 1, 1, 2, 3],         // bottom
        
        [4, 0, 5, 5, 0, 1],         // front_1
        [5, 1, 7, 7, 1, 3],         // right_1
        [7, 3, 6, 6, 3, 2],         // back_1
        [6, 2, 4, 4, 2, 0],         // left_1
        
        [8, 4, 9, 9, 4, 5],         // front_2
        [9, 5, 11, 11, 5, 7],       // right_2
        [11, 7, 10, 10, 7, 6],      // back_2
        [10, 6, 8, 8, 6, 4],        // left_2
        
        [12, 8, 13, 13, 8, 9],      // front_3
        [13, 9, 15, 15, 9, 11],     // right_3
        [15, 11, 14, 14, 11, 10],   // back_3
        [14, 10, 12, 12, 10, 8],    // left_3

        [16, 12, 17, 17, 12, 13],   // front_4
        [17, 13, 19, 19, 13, 15],   // right_4
        [19, 15, 18, 18, 15, 14],   // back_4
        [18, 14, 16, 16, 14, 12],   // left_4

        [20, 16, 21, 21, 16, 17],   // front_4
        [21, 17, 23, 23, 17, 19],   // right_4
        [23, 19, 22, 22, 19, 18],   // back_4
        [22, 18, 20, 20, 18, 16],   // left_4
        
        [22, 20, 23, 23, 20, 21],   // top
    ];
    
    const indices = [...boxFaces].flat();
  
    const boxPositions = [
        [-0.5, 0, 0.5],     // 0
        [0.5, 0, 0.5],      // 1
        [-0.5, 0, -0.5],    // 2
        [0.5, 0, -0.5],     // 3
        [-0.5, 1, 0.5],     // 4
        [0.5, 1, 0.5],      // 5
        [-0.5, 1, -0.5],    // 6
        [0.5, 1, -0.5],     // 7
        [-0.5, 2, 0.5],     // 8
        [0.5, 2, 0.5],      // 9
        [-0.5, 2, -0.5],    // 10
        [0.5, 2, -0.5],     // 11
        [-0.5, 3, 0.5],     // 12
        [0.5, 3, 0.5],      // 13
        [-0.5, 3, -0.5],    // 14
        [0.5, 3, -0.5],     // 15
        [-0.5, 4, 0.5],     // 16
        [0.5, 4, 0.5],      // 17
        [-0.5, 4, -0.5],    // 18
        [0.5, 4, -0.5],     // 19
        [-0.5, 5, 0.5],     // 20
        [0.5, 5, 0.5],      // 21
        [-0.5, 5, -0.5],    // 22
        [0.5, 5, -0.5],     // 23
    ].flat(); 
    
    const boxColors = [
        ...(new Array(4).fill(0).map(() => [1, 0, 0])), // 0段目
        ...(new Array(4).fill(0).map(() => [0, 1, 0])), // 1段目
        ...(new Array(4).fill(0).map(() => [0, 0, 1])), // 2段目
        ...(new Array(4).fill(0).map(() => [1, 1, 0])), // 3段目
        ...(new Array(4).fill(0).map(() => [0, 1, 1])), // 4段目
        ...(new Array(4).fill(0).map(() => [1, 0, 1])), // 5段目
    ].flat();
    
    return new VertexArrayObject({
        gpu,
        attributes: {
            position: {
                data: boxPositions,
                size: 3,
                location: 0,
                usageType: AttributeUsageTypes.StaticDraw
            },
            color: {
                data: boxColors,
                size: 3,
                location: 1,
                usageType: AttributeUsageTypes.StaticDraw
            },
            aBoneIndices: {
                data: (new Array(6 * 4).fill(0).map((elem, i) => boneIndicesEachHeight[Math.floor(i / 4)])).flat(),
                size: 4,
                location: 2,
                usageType: AttributeUsageTypes.StaticDraw
            },
            aBoneWeights: {
                data: (new Array(6 * 4).fill(0).map((elem, i) => boneWeightsEachHeight[Math.floor(i / 4)])).flat(),
                size: 4,
                location: 3,
                usageType: AttributeUsageTypes.StaticDraw
            },
        },
        indices
    });
}

const createBone = () => {
    const rootBone = new Bone({ name: "root_bone", index: 0 });
    rootBone.offsetMatrix = Matrix4.translationMatrix(new Vector3(0, 0.5, 0)); // offset
    
    const childBone1 = new Bone({ name: "child_bone_1", index: 1 });
    const bone1m = Matrix4.translationMatrix(new Vector3(0, 1, 0));
    childBone1.offsetMatrix = bone1m; // offset from parent (root bone)
    rootBone.addChild(childBone1);

    const childBone2 = new Bone({ name: "child_bone_2", index: 2 });
    const bone2m = Matrix4.translationMatrix(new Vector3(0, 1, 0));
    childBone2.offsetMatrix = bone2m; // offset from parent (child bone 1)
    childBone1.addChild(childBone2);

    const childBone3 = new Bone({ name: "child_bone_3", index: 3 });
    childBone3.offsetMatrix = Matrix4.translationMatrix(new Vector3(0, 1, 0)); // offset from parent (child bone 2)
    childBone2.addChild(childBone3);

    const childBone4 = new Bone({ name: "child_bone_4", index: 4 });
    childBone4.offsetMatrix = Matrix4.translationMatrix(new Vector3(0, 1, 0)); // offset from parent (child bone 3)
    childBone3.addChild(childBone4);

    rootBone.calcBoneOffsetMatrix();
   
    rootBone.boneOffsetMatrix.log();
    childBone1.boneOffsetMatrix.log();
    childBone2.boneOffsetMatrix.log();
    childBone3.boneOffsetMatrix.log();
    childBone4.boneOffsetMatrix.log();
    // rootBone.poseMatrix.log();
    // childBone1.poseMatrix.log();
    // childBone2.poseMatrix.log();
    // childBone3.poseMatrix.log();
    // childBone4.poseMatrix.log();
    
    const updateBone = (time) => {
        const rot = (Math.sin(time) * 45) * Math.PI / 180;
        childBone1.offsetMatrix = Matrix4.multiplyMatrices(
            Matrix4.translationMatrix(new Vector3(0, 1, 0)),
            Matrix4.rotationZMatrix(rot)
        );
        childBone2.offsetMatrix = Matrix4.multiplyMatrices(
            Matrix4.translationMatrix(new Vector3(0, 1, 0)),
            Matrix4.rotationZMatrix(rot)
        );
        childBone3.offsetMatrix = Matrix4.multiplyMatrices(
            Matrix4.translationMatrix(new Vector3(0, 1, 0)),
            Matrix4.rotationZMatrix(rot)
        );
    }

    return {
        rootBone,
        updateBone,
    }
}

const createShader = () => {
    return new Shader({
        gpu,
        vertexShader: `#version 300 es
    
layout (location = 0) in vec3 aPosition;   
layout (location = 1) in vec3 aColor; 
layout (location = 2) in vec4 aBoneIndices;
layout (location = 3) in vec4 aBoneWeights;

uniform mat4 uWorldMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;

uniform mat4[5] uBoneOffsetMatrices;
uniform mat4[5] uJointMatrices;

out vec3 vColor;

void main() {
    vColor = aColor;
    
    mat4 boneOffsetMatrix =
        uBoneOffsetMatrices[int(aBoneIndices.x)] * aBoneWeights.x * 
        uBoneOffsetMatrices[int(aBoneIndices.y)] * aBoneWeights.y *
        uBoneOffsetMatrices[int(aBoneIndices.z)] * aBoneWeights.z *
        uBoneOffsetMatrices[int(aBoneIndices.w)] * aBoneWeights.w;
     mat4 jointMatrix =
        uJointMatrices[int(aBoneIndices.x)] * aBoneWeights.x * 
        uJointMatrices[int(aBoneIndices.y)] * aBoneWeights.y *
        uJointMatrices[int(aBoneIndices.z)] * aBoneWeights.z *
        uJointMatrices[int(aBoneIndices.w)] * aBoneWeights.w;
    
    // gl_Position = uProjectionMatrix * uViewMatrix * uWorldMatrix * vec4(aPosition, 1.);
    // gl_Position = uProjectionMatrix * uViewMatrix * uWorldMatrix * boneOffsetMatrix * vec4(aPosition, 1.);
    gl_Position = uProjectionMatrix * uViewMatrix * uWorldMatrix * jointMatrix * boneOffsetMatrix * vec4(aPosition, 1.);
}
    `,
        fragmentShader: `#version 300 es
precision mediump float;
in vec3 vColor;
out vec4 outColor;
void main() {
    outColor = vec4(vColor, 1.);
}
    `
    });   
}

// ----------------------------------------------------------------------------------
// main
// ----------------------------------------------------------------------------------

const main = () => {
    const targetCameraPosition = new Vector3(0, 0, 8);
    
    let width;
    let height;
    
    const geometry = createGeometry();
    const shader = createShader();
    const uniforms = {
        uProjectionMatrix: {
            type: UniformTypes.Matrix4,
            value: Matrix4.identity()
        },
        uViewMatrix: {
            type: UniformTypes.Matrix4,
            value: Matrix4.identity()
        },
        uWorldMatrix: {
            type: UniformTypes.Matrix4,
            value: Matrix4.identity()
        },
        uBoneOffsetMatrices: {
            type: UniformTypes.Matrix4Array,
            value: (new Array(5).fill(0).map(() => Matrix4.identity()))
        },
        uJointMatrices: {
            type: UniformTypes.Matrix4Array,
            value: (new Array(5).fill(0).map(() => Matrix4.identity()))
        },
    };
    const { rootBone, updateBone } = createBone();
    
    const onMouseMove = (e) => {
        const nx = (e.clientX / width) * 2 - 1;
        const ny = (e.clientY / height) * 2 - 1;
        targetCameraPosition.x = nx * 4;
        targetCameraPosition.y = -ny * 4 + 2;
    };
    
    const onWindowResize = () => {
        width = wrapperElement.offsetWidth;
        height = wrapperElement.offsetHeight;
        
        canvasElement.width = width;
        canvasElement.height = height;
        
        gpu.setSize(0, 0, width, height);
       
        const fov = 60;
        const aspect = width / height;
        const near = 1;
        const far = 20;
        const projectionMatrix = Matrix4.getPerspectiveMatrix(fov * Math.PI / 180, aspect, near, far);
        uniforms.uProjectionMatrix.value = projectionMatrix;
    };
     
    const getBoneOffsetMatrices = () => {
        const matrices = [];
        rootBone.traverse((bone) => {
            const m = bone.boneOffsetMatrix.clone();
            matrices.push(m);
        });
        return matrices;
    }
    
    const getBoneJointMatrices = () => {
        const matrices = [];
        rootBone.traverse((bone) => {
            const m = bone.jointMatrix.clone();
            matrices.push(m);
        });
        return matrices;        
    }
    
    const tick = (time) => {
        const cameraLookAtPosition = new Vector3(0, 2, 0);
        const cameraWorldMatrix = Matrix4.getLookAtMatrix(targetCameraPosition, cameraLookAtPosition, Vector3.up(), true);
        uniforms.uViewMatrix.value = cameraWorldMatrix.invert();
        
        updateBone(time / 1000);
       
        rootBone.calcJointMatrix();
        // ボーンオフセット行列を計算
        const boneOffsetMatrices = getBoneOffsetMatrices();
        const boneJointMatrices = getBoneJointMatrices();
        // offset行列を踏まえたjoint行列を計算
        // const jointMatrices = boneOffsetMatrices.map((boneOffsetMatrix, i) => Matrix4.multiplyMatrices(boneJointMatrices[i], boneOffsetMatrix));
        
        uniforms.uBoneOffsetMatrices.value = boneOffsetMatrices;
        uniforms.uJointMatrices.value = boneJointMatrices
        
        // console.log("##################")
        // console.log(boneOffsetMatrices)
        // boneOffsetMatrices.forEach(m => m.log());
        // console.log("-------------------------")
        // console.log(boneJointMatrices)
        // boneJointMatrices.forEach(m => m.log());
        
        gpu.clear(0, 0, 0, 1);
        
        gpu.setVertexArrayObject(geometry);
        gpu.setShader(shader);
        gpu.setUniforms(uniforms);
        
        const drawCount = geometry.indices.length;
        gpu.draw({ drawCount });
        
        gpu.flush();
        
        requestAnimationFrame(tick);
    };

    onWindowResize();
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('mousemove', onMouseMove);
    requestAnimationFrame(tick);
};

main();

</script>

</body>
</html>